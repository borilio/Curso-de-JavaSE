[TOC]

---

# Clase Object

En Java, **todos los objetos** heredan de la clase `Object`. Esto significa que cualquier clase que crees en Java, ya sea directamente o a trav√©s de herencia, tiene algunos m√©todos b√°sicos que provienen de `Object`. Entre estos m√©todos, se encuentran algunos que son muy importantes para personalizar el comportamiento de tus clases, como `toString()`, `equals()` y `compareTo()`.

¬øPor qu√© es esto importante? Al sobrescribir estos m√©todos, puedes hacer que tus clases sean m√°s √∫tiles, ya que el comportamiento por defecto de la clase `Object` puede no ser el que necesitas. A continuaci√≥n, veremos estos m√©todos y c√≥mo se pueden sobrescribir para ajustarlos a nuestras necesidades.

> [!important]
>
> Solo tendr√°s que preocuparte de sobrescribir estos m√©todos en tus propias clases. Los tipos primitivos y la clase `String` ya tienen sobrescritos los m√©todos `toString()`, `equals()` y `compareTo()`, por lo que puedes usarlos directamente para comparaciones y conversiones sin necesidad de redefinirlos.

---

## üßîClase Persona

En todos los ejemplos usaremos una clase simple llamada `Persona`. Siempre se pondr√° todo el c√≥digo necesario para los ejemplos concretos, pero para que te hagas una idea de todo el c√≥digo de la clase, aqu√≠ la tienes completa:

```java
public class Persona {
    private String nombre;
    private int edad;

    public Persona(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }
}
```



---

## üîµ `hashCode()`

El m√©todo `hashCode()` es un m√©todo de la clase `Object` que devuelve un valor entero, conocido como el **c√≥digo hash** del objeto. Sirve para identificar de forma un√≠voca al objeto dentro de la memoria. No hay dos objetos distintos que tengan el mismo hashcode.

```java
Persona persona = new Persona("Juan", 25);
System.out.println(persona.hashCode()); //Imprime: 1791741888
```

Si imprimimos un objeto sin llamar a ning√∫n m√©todo, Java llama de forma impl√≠cita al m√©todo `toString()` que tienen los objetos:

```java
Persona persona = new Persona("Juan", 25);
System.out.println(persona); 			 // Imprime: Persona@6acbcfc0
System.out.println(persona.toString());  // Imprime: Persona@6acbcfc0
```

Esto indica que el m√©todo `toString()` por defecto de la clase `Object` se ha llamado, que devuelve el nombre de la clase (`Persona`) seguido del s√≠mbolo `@` y el hashcode del objeto en formato hexadecimal (`6acbcfc0`). 

Esto no proporciona informaci√≥n √∫til sobre los atributos del objeto y es por eso que se recomienda sobrescribir el m√©todo `toString()` para obtener una representaci√≥n m√°s clara y significativa.

> [!tip]
>
> Aunque el m√©todo `hashCode()` no suele usarse mucho, es conveniente saber que existe para entender mejor los conceptos de POO y de identidad de los objetos.

---



## üîµ`toString()`

El m√©todo `toString()` se utiliza para obtener una **representaci√≥n en texto** de un objeto. Por defecto, este m√©todo devuelve el nombre de la clase y el c√≥digo hash del objeto. Sin embargo, en la mayor√≠a de los casos, querr√°s que este m√©todo devuelva una descripci√≥n m√°s clara y √∫til de tu objeto.

**Ejemplo de sobrescritura de `toString()`:**

```java
@Override
public String toString() {
    return "Me llamo " + this.nombre + ", y tengo " + this.edad + " a√±os.";
}
```
Sobrescribir `toString()` te permite personalizar el texto que representa tu objeto cuando lo imprimes o lo conviertes a una cadena de texto.

> [!important]
>
> La anotaci√≥n `@Override` se usa en Java para **indicar expl√≠citamente que un m√©todo est√° sobrescribiendo un m√©todo de una clase padre o una interfaz**. Aunque no es obligatoria, tiene varias ventajas importantes:
>
> 1. **Verificaci√≥n del compilador**: Al usar `@Override`, el compilador verifica que realmente est√°s sobrescribiendo un m√©todo existente. Si cometes un error en el nombre, la firma del m√©todo o el tipo de retorno, el compilador te dar√° un error. Esto ayuda a evitar errores comunes.
> 2. **Mejora la legibilidad**: Al incluir `@Override`, dejas claro que el m√©todo tiene su origen en una clase o interfaz superior, lo que facilita la lectura del c√≥digo y su comprensi√≥n.
> 3. **Mantenimiento del c√≥digo**: Si en el futuro alguien modifica la clase base o interfaz y cambia el m√©todo que cre√≠as sobrescribir, la anotaci√≥n `@Override` har√° que el compilador detecte el error, evitando comportamientos inesperados.

Aunque tienes libertad para personalizar el m√©todo `toString()` como quieras, es recomendable seguir un **formato est√°ndar** que haga m√°s f√°cil la lectura y comprensi√≥n de los objetos en diferentes contextos. La forma m√°s com√∫n y recomendada es representar el objeto as√≠: 

```java
@Override
public String toString() {
    return "Persona{nombre='" + nombre + "', edad=" + edad + '}';
}
```

```
Persona{nombre='Max Power', edad=25}
```

Este formato muestra el nombre de la clase seguido de `{}` y una lista de sus atributos clave con sus valores correspondientes separados por comas. Este enfoque es √∫til porque es claro, f√°cil de entender y facilita la depuraci√≥n y el an√°lisis del comportamiento de los objetos en el c√≥digo, manteniendo un estilo coherente y profesional.

---



## üîµ`equals()`

El m√©todo `equals()` se usa para **comparar si dos objetos son iguales**. Por defecto, este m√©todo solo compara si dos objetos **son el mismo** en memoria (es decir, si son la misma instancia). Sin embargo, en muchos casos, querr√°s comparar objetos bas√°ndote en sus atributos. 

Nosotros hacemos las comprobaciones que necesitemos y **finalmente tenemos que retornar `true` si hemos considerado que son iguales o `false` en caso contrario**.

### Sobrescritura personalizada de `equals()`

```java
@Override
public boolean equals(Object obj) {
    Persona persona = (Persona) obj; // Hacemos casting para poder acceder a sus atributos
    // La siguiente expresi√≥n dar√° true o false
    return this.nombre.equals(persona.getNombre()) && this.edad == persona.getEdad();
}
```

Al sobrescribir `equals()`, puedes definir **qu√© significa que dos objetos sean iguales**, comparando los atributos que tu quieras. Aqu√≠ en el ejemplo anterior hemos comparado que un objeto tenga el mismo nombre y edad que otro. Si se da ese caso retorna un `true`, o `false` en caso contrario.

> [!important]
>
> **Tu decides qu√© comprobaciones quieres realizar para determinar que dos objetos son iguales**. Por ejemplo, si tuvi√©semos el atributo `nif`, podr√≠amos determinar que si sus `nif` son iguales, los objetos son iguales. A pesar de que tengan distinto `nombre` y/o `edad`.

Tenemos que hacer *casting* ya que el m√©todo debe recibir un objeto ya que as√≠ est√° definido en la clase `Object`. Gracias al polimorfismo podemos pasar un como par√°metro una clase m√°s concreta como `Persona` y despu√©s hacerle casting para poder acceder a sus m√©todos. 

### üõüSeguridad ante todo

**Pero hay un peque√±o problema de seguridad**. Como el m√©todo `equals()` puede recibir un `Object`, qui√©n use ese m√©todo podr√≠a enviarnos cualquier objecto de cualquier clase. El problema viene al hacerle el casting. ¬øQue pasar√≠a intentamos hacer un **cast** de un objeto a una clase que no es compatible? **El programa lanzar√° una excepci√≥n de tipo `ClassCastException`** y terminar√° su ejecuci√≥n. 

### Sobrescritura personalizada mejorada de `equals()` 

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    Persona persona = (Persona) obj;
    return this.nombre.equals(persona.getNombre()) && this.edad == persona.getEdad();
}
```

- Primero, **comparamos si los objetos a comparar son el mismo**. Si son el mismo, es obvio que son iguales, por lo que retornamos `true` y terminamos la ejecuci√≥n.
- Segundo, **si el objeto recibido es `null`**  retornamos un `false`.
- Tercero, **si los objetos a comparar son de distintas clases**, retornamos `false`.
- Y ya realizadas las comprobaciones, procedemos a hacer casting sin riesgos y a hacer las comprobaciones que queramos.



> [!tip]
>
> ü§ìLas sentencias `return` al principio simplifican el c√≥digo ya que evitan tener que seguir haciendo comprobaciones cuando ya hemos determinado un resultado. A√∫n as√≠, aqu√≠ tienes otra opci√≥n que hace lo mismo con un √∫nico `return`.
>
> ```java
> @Override
> public boolean equals(Object obj) {
>     // Variable auxiliar donde guardar el resultado
>     boolean esIgual = false;  // Por defecto son distintos
> 
>     //Si son el mismo
>     if (this == obj) {
>         esIgual = true;
>     } else if (obj != null && this.getClass() == obj.getClass()) {
>         //Ya sabemos que no es nulo y son de la misma clase, por lo que hacemos el casting sin miedo
>         Persona persona = (Persona) obj;
>         //Si tienen el mismo nombre y edad, es que son iguales
>         if (this.nombre.equals(persona.getNombre()) && this.edad == persona.getEdad()) {
>             esIgual = true;
>         }
>     }
> 
>     return esIgual;  // Solo tenemos un √∫nico return
> }
> ```

### ‚≠êSobrescritura r√°pida de equals()

Una forma r√°pida de sobrescribir el m√©todo `equals()` en una clase es utilizando el m√©todo `toString()` de los objetos para comparar sus representaciones en cadena. Por ejemplo, si tenemos una clase `Persona` con atributos como `nombre` y `edad`, podr√≠amos sobrescribir `equals()` de la siguiente manera:

```java
@Override
public boolean equals(Object otro) {
    return this.toString().equals(otro.toString());
}
```

Realmente lo que estamos comparando es que ambos `toString()` sean iguales. ES una forma simple y eficiente de comprobar que los objetos ‚Äúsean iguales‚Äù. Si alg√∫n atributo es distinto cambiar√° la salida del `toString()` ya no coincidir√° y dir√° que son distintos.

Si adem√°s queremos hacer las [comprobaciones de seguridad](#üõüSeguridad ante todo) explicadas antes, ser√≠a:

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Persona persona = (Persona) obj;
    return this.toString().equals(persona.toString());
}
```

> [!tip]
>
> El usar el `equals()` de la clase String en nuestro propio `equals()` nos ahorra tener que ir comparando atributo por atributo para determinar si los objetos son iguales.




---

## üîµ`compareTo()`

La sobrescritura del m√©todo `compareTo()` es una de las claves para permitir que los objetos de una clase puedan **ordenarse** de forma natural, y se hace cuando implementamos la interfaz `Comparable`. 

Si intentas comparar dos objetos de una clase cualquiera utilizando **operadores de igualdad** como `!=` o `==`, te encontrar√°s con que no provocar√° ning√∫n error, pero lo que se est√° comparando en realidad es la **referencia** en memoria (hashcode) y no el contenido de los objetos (sus atributos).

> [!warning]
>
> Los operadores `>`, `<`, `>=`, `<=` **si provocar√°n un error de compilaci√≥n** si usan en expresiones con objetos porque los operadores relacionales est√°n definidos solo para tipos primitivos num√©ricos o caracteres.

Sabemos comparar atributos de un objeto, pero ¬øpodemos comparar dos objetos directamente para saber cual es ‚Äúmayor‚Äù o ‚Äúmenor‚Äù?. Esto es indispensable para poder ordenar una lista de objetos.

El m√©todo `compareTo()` se utiliza para **comparar dos objetos** de la misma clase y determinar su orden. Devuelve un n√∫mero entero que indica si el objeto actual (el que llama al m√©todo) es "menor", "igual" o "mayor" que el objeto que se pasa como par√°metro. El resultado se interpreta de la siguiente manera:

- **Un n√∫mero negativo**: significa que el objeto actual (`this`) es "menor" que el objeto comparado.
- **Cero (0)**: significa que ambos objetos son "iguales" en cuanto al criterio de orden.
- **Un n√∫mero positivo**: significa que el objeto actual (`this`) es "mayor" que el objeto comparado.

### Sobrescritura personalizada de `compareTo()`

Imagina que tenemos una clase `Persona` que queremos ordenar por la edad de las personas:

```java
public class Persona implements Comparable<Persona> {
    private String nombre;
    private int edad;

    // Constructores
    ...

    @Override
    public int compareTo(Persona otraPersona) {
        // Comparando por edad
        if (this.edad < otraPersona.edad) {
            return -1; // El objeto actual es menor
        } else if (this.edad > otraPersona.edad) {
            return 1;  // El objeto actual es mayor
        } else {
            return 0;  // Ambos son iguales en edad
        }
    }

    // Getters para nombre y edad
    ...
}
```

**Explicaci√≥n paso a paso:**

1. **Implements Comparable**: Implementamos la interfaz `Comparable<Persona>`, que nos obliga a sobrescribir el m√©todo `compareTo()`.
2. **Comparaci√≥n**: Dentro de `compareTo()`, comparamos la edad del objeto actual (`this.edad`) con la edad del objeto que estamos pasando como par√°metro (`otraPersona.edad`).
3. **Resultado**:
   - Si el objeto actual es m√°s joven (`this.edad < otraPersona.edad`), devolvemos -1, indicando que es "menor".
   - Si es m√°s viejo (`this.edad > otraPersona.edad`), devolvemos 1, indicando que es "mayor".
   - Si tienen la misma edad (`this.edad == otraPersona.edad`), devolvemos 0, indicando que son "iguales" en este aspecto.

Este enfoque permite que los objetos de la clase `Persona` se ordenen autom√°ticamente, por ejemplo, en un `ArrayList` usando `Collections.sort()`.

> [!tip]
>
> üìùEl m√©todo `compareTo()` define c√≥mo se comparan dos objetos de la misma clase, devolviendo un valor que permite saber cu√°l debe ir antes o despu√©s. Sobrescribir este m√©todo es clave para poder ordenar los objetos de una forma l√≥gica, ya sea por un atributo num√©rico, alfab√©tico, o cualquier otro criterio.

> [!tip]
>
> ü§ìSi vamos a comparar √∫nicamente n√∫meros, es m√°s f√°cil hacer lo siguiente:
>
> ```java
> @Override
> public int compareTo(Persona otraPersona) {
>     return this.edad - otraPersona.edad;
> }
> ```
>
> Seguimos cumpliendo las reglas. La cantidad devuelta da exactamente igual, solo importa si es negativo, `0` √≥ positivo.



### ‚≠êSobrescritura r√°pida de compareTo()

Para implementar el m√©todo `compareTo()` de forma r√°pida en una clase, puedes aprovechar el m√©todo `toString()` para comparar las representaciones en cadena de los objetos. 

Por ejemplo, si defines el m√©todo `toString()` en tu clase de manera que los atributos se concatenen en un orden espec√≠fico (como nombre, edad), puedes utilizar `this.toString().compareTo(otraPersona.toString())` dentro de `compareTo()`. Esto permitir√° que los objetos se ordenen seg√∫n el criterio establecido en el `toString()`. 

```java
@Override
public int compareTo(Persona otraPersona) {
    return this.toString().compareTo(otraPersona.toString());
}

@Override
public String toString() {
    return "Persona{nombre='" + nombre + "', edad=" + edad + '}'; 
    // Aseg√∫rate de que el orden de los atributos sea el deseado
}

```

> [!note]
>
> No es necesario comprobar las clases ni hacer casting porque no accedemos a los atributos de la clase y usamos el `toString()`, que lo tiene seguro porque lo tienen todos los objetos.

> [!caution]
>
> Si el objeto recibido es `null`, al hacer la llamada al `toString()` si que provocaremos una excepci√≥n de tipo `NullPointerException`. A veces est√° bien que dejemos que salten las excepciones porque si no, no nos daremos cuenta del error y ser√° m√°s dif√≠cil detectarlo.

> [!important]
>
> Es crucial que los atributos en el `toString()` est√©n organizados de manera coherente para que la comparaci√≥n sea l√≥gica y cumpla con el objetivo de ordenaci√≥n deseado. Si mostramos primero el nombre y despu√©s la edad, como las cadenas se comparan de forma lexicogr√°fica, en primer lugar se ordenar√°n por nombre y en caso de igualdad, por edad.

> [!warning]
>
> Al comparar dos cadenas usando el m√©todo `compareTo()`, la comparaci√≥n se realiza de forma **lexicogr√°fica**, similar a c√≥mo se ordenan las palabras en un diccionario. Esto significa que se compara car√°cter por car√°cter seg√∫n su valor Unicode, y no se toman en cuenta los valores num√©ricos en su contexto. 
>
> Por ejemplo, al comparar las cadenas `"10"` y `"2"`, el resultado ser√° que `"10"` es menor que `"2"` porque el primer car√°cter (`'1'`) de `"10"` tiene un valor Unicode menor que el car√°cter `'2'`. Esto puede llevar a resultados inesperados si se espera que se ordenen como n√∫meros. Por lo tanto, al utilizar `toString()` para la comparaci√≥n, es importante asegurarse de que los atributos sean ordenados adecuadamente en formato de cadena si se desea un orden num√©rico.

> [!tip]
>
> ü§ìY con este truco, hemos usado los 5 tipos de avisos üëå.

---

